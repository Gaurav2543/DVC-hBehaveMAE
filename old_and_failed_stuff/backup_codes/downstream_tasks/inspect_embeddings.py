"""
inspect_embeddings.py

A utility script to load and inspect the contents of an .npz file
generated by the hBehaveMAE embedding extraction pipeline.

It provides a detailed breakdown of the shape, data types, and content
of the saved embeddings, timestamps, and frame map, along with
inferences about the data's structure and integrity.

Usage:
    python inspect_embeddings.py /path/to/your/embeddings_file.npz
"""
import argparse
import numpy as np
import pandas as pd

def inspect_embeddings_file(file_path):
    """Loads and analyzes the contents of a given .npz file."""
    print(f"--- üîç Inspecting File: {file_path} ---")

    try:
        # allow_pickle=True is required to load the 'frame_map' dictionary
        data = np.load(file_path, allow_pickle=True)
        keys = list(data.keys())
        print(f"‚úÖ File loaded successfully. Found keys: {keys}")
    except Exception as e:
        print(f"‚ùå Error loading file: {e}")
        return

    # --- 1. Inspect 'embeddings' array ---
    if 'embeddings' in keys:
        embeds = data['embeddings']
        print("\n## 1. Embeddings Array")
        print(f"   - Shape: {embeds.shape}")
        print(f"     - Interpretation: This matrix contains {embeds.shape[0]} per-minute embeddings, each with {embeds.shape[1]} learned features.")
        print(f"   - Data Type: {embeds.dtype}")
        print(f"   - Example Values (first 3 rows, first 8 dimensions):\n{embeds[:3, :8]}")
    else:
        print("\n## 1. Embeddings Array - Not Found!")

    # --- 2. Inspect 'timestamps' array ---
    if 'timestamps' in keys:
        timestamps = data['timestamps']
        print("\n## 2. Timestamps Array")
        print(f"   - Shape: {timestamps.shape}")
        print(f"     - Interpretation: This is a 1D array, with each entry corresponding to a row in the embeddings matrix.")
        print(f"   - Data Type: {timestamps.dtype}")
        if timestamps.size > 0:
            print(f"   - Time Range Covered: {pd.to_datetime(timestamps[0])} to {pd.to_datetime(timestamps[-1])}")
    else:
        print("\n## 2. Timestamps Array - Not Found!")

    # --- 3. Inspect 'frame_map' dictionary ---
    if 'frame_map' in keys:
        # .item() is needed to extract the dictionary from the 0-dimensional object array
        frame_map = data['frame_map'].item()
        print("\n## 3. Frame Map Dictionary")
        print(f"   - Type: {type(frame_map)}")
        print(f"   - Number of Cages Mapped: {len(frame_map)}")
        print("   - Interpretation: This maps each cage ID to the slice of rows [start, end) it occupies in the embeddings and timestamps arrays.")
        # Print first 3 cage mappings as an example
        for i, (cage, indices) in enumerate(frame_map.items()):
            if i >= 3:
                print("     ...")
                break
            print(f"     - Example: Cage '{cage}' corresponds to rows {indices[0]} through {indices[1]-1}.")
    else:
        print("\n## 3. Frame Map - Not Found!")

    # --- 4. Inferences and Sanity Checks ---
    print("\n## 4. Inferences from Structure")
    if 'embeddings' in keys and 'timestamps' in keys:
        if embeds.shape[0] == timestamps.shape[0]:
            print("   - ‚úÖ Shape Consistency: The number of embeddings perfectly matches the number of timestamps.")
        else:
            print(f"   - ‚ùå Shape Mismatch: Embeddings count ({embeds.shape[0]}) does not match timestamps count ({timestamps.shape[0]})!")
    
    if 'frame_map' in keys and 'embeddings' in keys:
        total_mapped_frames = sum(end - start for start, end in frame_map.values())
        if total_mapped_frames == embeds.shape[0]:
            print(f"   - ‚úÖ Frame Map Integrity: The frame map correctly accounts for all {total_mapped_frames} embedding vectors.")
        else:
            print(f"   - ‚ùå Frame Map Error: The frame map accounts for {total_mapped_frames} frames, but there are {embeds.shape[0]} embeddings!")
            
    print("\n--- Inspection Complete ---")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Inspect a hBehaveMAE embedding .npz file.")
    parser.add_argument("file_path", type=str, help="Path to the .npz file to inspect.")
    args = parser.parse_args()
    
    inspect_embeddings_file(args.file_path)